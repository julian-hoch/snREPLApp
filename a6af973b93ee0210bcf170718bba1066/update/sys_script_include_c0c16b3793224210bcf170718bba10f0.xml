<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>global.SnREPL</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>SnREPL</name>
        <script><![CDATA[/**
 * This Script Include manages the remote REPL session that can be accessed via
 * the REST API /api/890366/
 */
var SnREPL = {

    COMMAND_POLL_INTERVAL : 250,          // polling interval in ms
    COMMAND_TIMEOUT       : 15,           // timeout in seconds

    WORKER_MIN_DELAY      : 200,          // worker minimum delay in ms
    WORKER_MAX_DELAY      : 15000,        // worker maximum delay in ms
    WORKER_LAYOFF_DELAY   : 10,           // worker layoff delay in ms

    // Table and field names for the command queue
    CMD_TABLE             : 'u_snrepl_command',
    CMD_STATE             : 'u_state',
    CMD_COMMAND           : 'u_command',
    CMD_RESULT            : 'u_result',
    CMD_SESSION           : 'u_session',

    // Table and field names for the session table, and session settings
    SESSION_TABLE         : 'u_snrepl_session',
    SESSION_STATE         : 'u_state',
    SESSION_IDLE_TIMEOUT  : 15*60,        // 15 minutes


    /**
     * Handles request to execute a command.
     *     
     * @param {RESTAPIRequest} request The incoming request
     * @param {RESTAPIResponse} response The response 
     * @modifies response
     */
    postCommand: function(request, response) {
        var command = request.body.data.Command;
        var session = request.body.data.Session;
        gs.info('SnREPL: Processing command: ' + command + ' in session ' + session);
        var result = SnREPL.processCommand(command, session)
        var body = {
            data: result
        };
        response.setBody(body);
    },

    /**
     * Handles request for new session.
     *
     * @param {RESTAPIRequest} request The incoming request
     * @param {RESTAPIResponse} response The response
     * @modifies response
     */
    postSession: function(request, response) {
        gs.info('SnREPL: Creating new session');
        var session = SnREPL.createSession();
        response.setBody({
            data: session
        });
        gs.info('SnREPL: Created new session: ' + session.name);
    },

    /**
     * Handles request to list all active sessions.
     *
     * @param {RESTAPIRequest} request The incoming request
     * @param {RESTAPIResponse} response The response
     * @modifies response
     */
    listSessions: function(request, response) {
        var gr = new GlideRecord(SnREPL.SESSION_TABLE);
        gr.query();
        var sessions = [];
        while (gr.next()) {
            sessions.push({
                id: gr.getUniqueValue(),
                name: gr.getDisplayValue(),
                state: gr.getValue(SnREPL.SESSION_STATE)
            });
        }
        response.setBody({
            data: sessions
        });
    },

    /**
     * Processes the command and returns the result.
     *
     * Will enter the command into the command queue and then
     * poll for the result until it is available.
     *
     * @param {string} command the command to process
     * @param {string} session the session ID
     * @returns {any} the result of the command
     */
    processCommand: function(command, session) {
        var cid = -1;
        var response;

        // check if session exists and is live
        var grSession = new GlideRecord(SnREPL.SESSION_TABLE);
        if (!grSession.get(session)) {
            throw new Error('SnREPL: Session ' + session + ' does not exist');
        }

        if (grSession.getValue(SnREPL.SESSION_STATE) != 'live') {
            throw new Error('SnREPL: Session ' + session + ' is not active');
        }

        // create new command record
        var gr = new GlideRecord(SnREPL.CMD_TABLE);
        gr.newRecord();
        gr.setValue(SnREPL.CMD_STATE, 'new');
        gr.setValue(SnREPL.CMD_COMMAND, command);
        gr.setValue(SnREPL.CMD_SESSION, session);
        cid = gr.insert();

        if (!cid) {
            throw new Error('SnREPL: Could not create new command');
        }

        var stopwatch = new GlideStopWatch();
        var t = 0;

        while (t < SnREPL.COMMAND_TIMEOUT * 1000) {
            gr = new GlideRecord(SnREPL.CMD_TABLE);
            if (!gr.get(cid)) {
                throw new Error('SnREPL: Could not get command ' + cid);
            }

            var state = gr.getValue(SnREPL.CMD_STATE);
            response = {
                result: gr.getValue(SnREPL.CMD_RESULT)
            };

            if (state == 'done') {
                return response; 
            }

            gs.sleep(SnREPL.COMMAND_POLL_INTERVAL);
            t = stopwatch.getTime();
        }

        // return timeout message and command ID for result polling
        response = {
            result: 'timeout',
            command: cid
        };

        return response;
    },

    /**
     * Creates a new session record.
     *
     * @returns {object} the session ID and name
     */
    createSession: function() {
        var grSession = new GlideRecord(SnREPL.SESSION_TABLE);
        grSession.newRecord();
        var id;
        id = grSession.insert();
        if (!id) {
            throw new Error('SnREPL: Could not create new session');
        }
        return {
            id: id,
            name: grSession.getDisplayValue()
        };
    },


    /**
     * Starts up a new session process.
     */
    initSession: function(sessionGr) {
        gs.info('SnREPL: Initializing session ' + sessionGr.getDisplayValue());
        sessionGr.setValue(SnREPL.SESSION_STATE, 'live');
        sessionGr.update();
        SnREPL.watchCommands(sessionGr);
    },

    /**
     * Watch for new commands of a given session and process them.
     *
     * This background process will regularly poll the command queue
     * for new commands and process them. The results will be written
     * back to the command record, so they can be picked up by
     * the REST API handler and forwarded to the client.
     *
     * @param {GlideRecord} sessionGr the session record
     */
    watchCommands: function(sessionGr) {
        var sessionTimer = new GlideStopWatch();
        var inactiveTimer = new GlideStopWatch();
        var delay = SnREPL.WORKER_MIN_DELAY;
        var msgPrefix = 'SnREPL[' + sessionGr.getDisplayValue() + ']: ';

        // limited environment for command execution
        var env = {
            __printLog: [],
            __msgPrefix: msgPrefix
        };

        while (inactiveTimer.getTime() < SnREPL.SESSION_IDLE_TIMEOUT * 1000) {
            var gr = new GlideRecord(SnREPL.CMD_TABLE);
            gr.addQuery(SnREPL.CMD_SESSION, sessionGr.getUniqueValue());
            gr.addQuery(SnREPL.CMD_STATE, 'new');
            gr.orderBy('sys_created_on');
            gr.query();

            if (gr.next()) {
                var command = gr.getValue(SnREPL.CMD_COMMAND);
                var result = null;
                var status = null

                if (command.startsWith('#')) {
                    command = command.substring(1);
                    gs.info(msgPrefix + 'Processing session command: ' + command);

                    switch (command) {
                    case 'exit':
                        gs.info(msgPrefix + 'Session ' + sessionGr.getDisplayValue() + ' has been terminated.');
                        sessionGr.setValue(SnREPL.SESSION_STATE, 'inactive');
                        sessionGr.update();

                        gr.setValue(SnREPL.CMD_RESULT, JSON.stringify({
                            replMsg: 'Session terminated'
                        }));
                        
                        gr.setValue(SnREPL.CMD_STATE, 'done');
                        gr.update();
                        return;
                    default:
                        gs.warn(msgPrefix + 'Unknown session command: ' + command);
                        result = 'Unknown command: ' + command;
                    }
                } else {
                    gs.info(msgPrefix + 'Processing command: ' + command);
                    try {
                        result = SnREPL.runCommand.call(env, gr);
                        status = 'success';
                    } catch (e) {
                        gs.warn(msgPrefix + 'Error: ' + e.message);
                        result = e.message;
                        status = 'exception';
                    }
                }

                if (typeof result == 'object') {
                    result = JSON.stringify(result);
                }

                var response = {
                    result: result,
                    printLog: env.__printLog,
                    status: status
                }

                gr.setValue(SnREPL.CMD_RESULT, JSON.stringify(response));
                gr.setValue(SnREPL.CMD_STATE, 'done');
                gr.update();
                delay = SnREPL.WORKER_MIN_DELAY;
                inactiveTimer.start();
            } else if (delay < SnREPL.WORKER_MAX_DELAY) {
                delay += SnREPL.WORKER_LAYOFF_DELAY;
            }

            gs.sleep(delay);
        }

        // Session has been inactive for too long, clean up
        sessionGr.setValue(SnREPL.SESSION_STATE, 'inactive');
        sessionGr.update();
        gs.info('SnREPL: Session ' + sessionGr.getDisplayValue() + ' has been inactive for too long, suspending.');
    },

    /**
     * Runs the given command in a limited environment, where
     * we also intercept calls to gs.print and console.log.
     *
     * @param {GlideRecord} commandGr the command record
     * @returns {any} the result of the command
     * @modifies this
     */
    runCommand: function(commandGr) {
        var __printLog = [];

        // Intercept calls to gs.print and console.log
        function logWrapper(msg) {
            var now = new GlideDateTime();
            __printLog.push({
                timestamp: now.getDisplayValue(),
                message: String(msg)
            });
        }
        var __gsWrapper = Object.create(gs);
        __gsWrapper.print = logWrapper; 
        __gsWrapper.sleep = gs.sleep.bind(gs);

        var __vars = {
            console: {
                log : logWrapper
            },
            gs: __gsWrapper
        };

        // Bug in GlideScopedEvaluator (cannot catch exceptions)
        /*var __gse = new GlideScopedEvaluator();
        for (var key in __vars) {
            __gse.putVariable(key, __vars[key]);
        }

        this.__retval = __gse.evaluateScript(commandGr, SnREPL.CMD_COMMAND);
        */


        // So we use eval for now
        console = __vars.console;
        gs = __vars.gs;
        
        this.__printLog = __printLog;
        return eval(commandGr.getValue(SnREPL.CMD_COMMAND));
    },

    /**
     * Terminates the given session.
     *
     * This will set the session state to 'inactive' and
     * terminate the session process.
     *
     * @param {GlideRecord} sessionGr the session record
     */
    terminateSession: function(sessionGr) {
        gs.info('SnREPL: Terminating session ' + sessionGr.getDisplayValue());
        var gr = new GlideRecord(SnREPL.CMD_TABLE);
        gr.newRecord();
        gr.setValue(SnREPL.CMD_STATE, 'new');
        gr.setValue(SnREPL.CMD_COMMAND, '#exit');
        gr.setValue(SnREPL.CMD_SESSION, sessionGr.getUniqueValue());
        gr.insert();
    },

    /** @type { string } */
    type: 'SnREPL'
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-06-09 19:09:20</sys_created_on>
        <sys_id>c0c16b3793224210bcf170718bba10f0</sys_id>
        <sys_mod_count>61</sys_mod_count>
        <sys_name>SnREPL</sys_name>
        <sys_package display_value="snREPL" source="a6af973b93ee0210bcf170718bba1066">a6af973b93ee0210bcf170718bba1066</sys_package>
        <sys_policy/>
        <sys_scope display_value="snREPL">a6af973b93ee0210bcf170718bba1066</sys_scope>
        <sys_update_name>sys_script_include_c0c16b3793224210bcf170718bba10f0</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-06-13 19:47:17</sys_updated_on>
    </sys_script_include>
</record_update>
