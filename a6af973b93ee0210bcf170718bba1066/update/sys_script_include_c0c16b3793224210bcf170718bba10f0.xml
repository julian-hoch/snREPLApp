<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>global.SnREPL</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>SnREPL</name>
        <script><![CDATA[/**
 * This Script Include manages the remote REPL session that can be accessed via
 * the REST API /api/890366/
 */
var SnREPL = {

    COMMAND_POLL_INTERVAL	: 250,		// polling interval in ms
    COMMAND_TIMEOUT		: 120,		// timeout in seconds

    WORKER_MIN_DELAY		: 200,		// worker minimum delay in ms
    WORKER_MAX_DELAY		: 15000,	// worker maximum delay in ms
    WORKER_LAYOFF_DELAY		: 10,		// worker layoff delay in ms

    // Table and field names for the command queue
    CMD_TABLE			: 'u_snrepl_command',
    CMD_STATE			: 'u_state',
    CMD_COMMAND			: 'u_command',
    CMD_RESULT			: 'u_result',
    CMD_SESSION			: 'u_session',

    // Table and field names for the session table, and session settings
    SESSION_TABLE		: 'u_snrepl_session',
    SESSION_STATE		: 'u_state',
    SESSION_IDLE_TIMEOUT	: 15*60,	// 15 minutes


    /**
     * Handles request to execute a command.
     
     * @param {RESTAPIRequest} request The incoming request
     * @param {RESTAPIResponse} response The response 
     * @modifies response
     */
    postCommand: function(request, response) {
	// try {
        var command = request.body.data.command;
	gs.info('SnREPL: Processing command: ' + command);
	var result = SnREPL.processCommand(command);
	gs.info('SnREPL: Command result: ' + result);
        var body = {
            data: result
        };
        response.setBody(body);
        /*} catch (error) {
          response.setStatus(500);
          var errorStr = SnREPL._serializeException(error);
          response.setBody(errorStr);
          }*/
    },

    /**
     * Handles request for new session.
     *
     * @param {RESTAPIRequest} request The incoming request
     * @param {RESTAPIResponse} response The response
     * @modifies response
     */
    postSession: function(request, response) {
	gs.info('SnREPL: Creating new session');
	var session = SnREPL.createSession();
	response.setBody({
	    data: session
	});
	gs.info('SnREPL: Created new session: ' + session.name);
    },




    /**
     * Processes the command and returns the result.
     *
     * Will enter the command into the command queue and then
     * poll for the result until it is available.
     *
     * @param {string} command the command to process
     * @returns {any} the result of the command
     */
    processCommand: function(command) {
        var cid = -1;

        var gr = new GlideRecord(SnREPL.CMD_TABLE);
        gr.newRecord();
        gr.setValue(SnREPL.CMD_STATE, 'new');
        gr.setValue(SnREPL.CMD_COMMAND, command);
        cid = gr.insert();

        if (!cid) {
            throw new Error('SnREPL: Could not create new command');
        }

        var stopwatch = new GlideStopWatch();
        var t = 0;

        while (t < SnREPL.COMMAND_TIMEOUT * 1000) {
            gr = new GlideRecord(SnREPL.CMD_TABLE);
            if (!gr.get(cid)) {
                throw new Error('SnREPL: Could not get command ' + cid);
            }

            var state = gr.getValue(SnREPL.CMD_STATE);
            var response = gr.getValue(SnREPL.CMD_RESULT);

            if (state == 'done') {
                break;
            }

            gs.sleep(SnREPL.COMMAND_POLL_INTERVAL);
            t = stopwatch.getTime();
        }

        return response;
    },

    /**
     * Creates a new session record.
     *
     * @returns {object} the session ID and name
     */
    createSession: function() {
	var grSession = new GlideRecord(SnREPL.SESSION_TABLE);
	grSession.newRecord();
	var id;
	id = grSession.insert();
	if (!id) {
	    throw new Error('SnREPL: Could not create new session');
	}
	return {
	    id: id,
	    name: grSession.getDisplayValue()
	};
    },


    /**
     * Converts the exception generated by ServiceNow into a string
     * that can be parsed on the client.
     *
     * @param {any} ex exception object to serialize
     * @returns {string} JSON string of exception object
     */
    _serializeException: function(ex) {
        var exObj = {};
        Object.getOwnPropertyNames(ex).forEach(function(key) {
            exObj[key] = ex[key];
        });
        // rhinoException is a Java object, so we need to force string conversion
        if ('rhinoException' in ex) {
            exObj.rhinoException = String(ex.rhinoException);
        }
        return JSON.stringify(exObj);
    },

    /**
     * Starts up a new session process.
     */
    initSession: function(sessionGr) {
	gs.info('SnREPL: Initializing session ' + sessionGr.getDisplayValue());
	sessionGr.setValue(SnREPL.SESSION_STATE, 'live');
	sessionGr.update();
	SnREPL.watchCommands(sessionGr);
    },

    /**
     * Watch for new commands of a given session and process them.
     *
     * This background process will regularly poll the command queue
     * for new commands and process them. The results will be written
     * back to the command record, so they can be picked up by
     * the REST API handler and forwarded to the client.
     *
     * @param {GlideRecord} sessionGr the session record
     */
    watchCommands: function(sessionGr) {
        var __sessionTimer = new GlideStopWatch();
	var __inactiveTimer = new GlideStopWatch();
	var __delay = SnREPL.WORKER_MIN_DELAY;
	var __msgPrefix = 'SnREPL[' + sessionGr.getDisplayValue() + ']: ';

	// Intercept calls to gs.print, gs.info, gs.warn, gs.error
	var __printLog = [];
	gs.print = function(msg) {
	    __printLog.push(msg);
	};

        while (__inactiveTimer.getTime() < SnREPL.SESSION_IDLE_TIMEOUT * 1000) {
            var __gr = new GlideRecord(SnREPL.CMD_TABLE);
            __gr.addQuery(SnREPL.CMD_SESSION, sessionGr.getUniqueValue());
	    __gr.addQuery(SnREPL.CMD_STATE, 'new');
	    __gr.orderBy('sys_created_on');
            __gr.query();

            if (__gr.next()) {
		var __gse = new GlideScopedEvaluator();

                var __result;
		var __output;
		__printLog = [];

		var command = __gr.getValue(SnREPL.CMD_COMMAND);
		if (command.startsWith('\\')) {
		    command = command.substring(1);
		    gs.info(__msgPrefix + 'Processing session command: ' + command);

		    switch (command) {
		    case 'exit':
			gs.info(__msgPrefix + 'Session ' + sessionGr.getDisplayValue() + ' has been terminated.');
			sessionGr.setValue(SnREPL.SESSION_STATE, 'inactive');
			sessionGr.update();

			__gr.setValue(SnREPL.CMD_RESULT, JSON.stringify({
			    replMsg: 'Session terminated'
			}));
			    
                __gr.setValue(SnREPL.CMD_STATE, 'done');
                __gr.update();
			return;
		    default:
			gs.warn(__msgPrefix + 'Unknown session command: ' + command);
			__result = 'Unknown command: ' + command;
		    }
		} else {
		    gs.info(__msgPrefix + 'Processing command: ' + command);

                    try {
	//		__result = GlideEvaluator.evaluateString(command);
			__result = __gse.evaluateScript(__gr, SnREPL.CMD_COMMAND);
			//		    var script = "(function() { return " + __gr.getValue('u_command') + " })();";
			//			__gr.getValue('u_command');
			//		    __result = eval(script);
                    } catch (e) {
			gs.warn(__msgPrefix + 'Error: ' + e.message);
			__result = e.message;
                    }
		}
		

		var response = {
		    result: __result,
		    printLog: __printLog
		}

                __gr.setValue(SnREPL.CMD_RESULT, JSON.stringify(response));
                __gr.setValue(SnREPL.CMD_STATE, 'done');
                __gr.update();
		__delay = SnREPL.WORKER_MIN_DELAY;
		__inactiveTimer.start();
            } else if (__delay < SnREPL.WORKER_MAX_DELAY) {
		__delay += SnREPL.WORKER_LAYOFF_DELAY;
	    }

            gs.sleep(__delay);
        }

	// Session has been inactive for too long, clean up
	sessionGr.setValue(SnREPL.SESSION_STATE, 'inactive');
	gs.info('SnREPL: Session ' + sessionGr.getDisplayValue() + ' has been inactive for too long, suspending.');
    },


    /** @type { string } */
    type: 'SnREPL'
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-06-09 19:09:20</sys_created_on>
        <sys_id>c0c16b3793224210bcf170718bba10f0</sys_id>
        <sys_mod_count>19</sys_mod_count>
        <sys_name>SnREPL</sys_name>
        <sys_package display_value="snREPL" source="a6af973b93ee0210bcf170718bba1066">a6af973b93ee0210bcf170718bba1066</sys_package>
        <sys_policy/>
        <sys_scope display_value="snREPL">a6af973b93ee0210bcf170718bba1066</sys_scope>
        <sys_update_name>sys_script_include_c0c16b3793224210bcf170718bba10f0</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-06-11 05:25:36</sys_updated_on>
    </sys_script_include>
</record_update>
