<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>global.SnREPL</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>SnREPL</name>
        <script><![CDATA[/**
 * This Script Include manages the remote REPL session that can be accessed via
 * the REST API /api/890366/send_command
 */
var SnREPL = {

    COMMAND_POLL_INTERVAL: 250, // polling interval in ms
    COMMAND_TIMEOUT: 120, // timeout in seconds

    WORKER_TTL: 3600, // worker time-to-live in seconds

    WORKER_MIN_DELAY: 100, // worker minimum delay in ms
    WORKER_MAX_DELAY: 15000, // worker maximum delay in ms
    WORKER_LAYOFF_DELAY: 1, // worker layoff delay in ms


    /**
     * Handles the incoming request. This function is the entry point for the
     * Scripted REST API.
     * 
     * @param {RESTAPIRequest} request The incoming request
     * @param {RESTAPIResponse} response The response 
     * @modifies response
     */
    handleRequest: function(request, response) {
        try {
            var command = request.body.data.command;
	    gs.info('SnREPL: Processing command: ' + command);
	    var result = SnREPL.processCommand(command);
	    gs.info('SnREPL: Command result: ' + result);
            var body = {
                data: result
            };
            response.setBody(body);
        } catch (error) {
            response.setStatus(500);
            var errorStr = SnREPL._serializeException(error);
            response.setBody(errorStr);
        }
    },


    /**
     * Processes the command and returns the result.
     *
     * Will enter the command into the command queue and then
     * poll for the result until it is available.
     *
     * @param {string} command the command to process
     * @returns {any} the result of the command
     */
    processCommand: function(command) {
        var cid = -1;

        var gr = new GlideRecord('u_repl_command');
        gr.newRecord();
        gr.setValue('u_state', 'new');
        gr.setValue('u_command', command);
        cid = gr.insert();

        if (!cid) {
            throw new Error('SnREPL: Could not create new command');
        }

        var stopwatch = new GlideStopWatch();
        var t = 0;

        while (t < SnREPL.COMMAND_TIMEOUT * 1000) {
            gr = new GlideRecord('u_repl_command');
            if (!gr.get(cid)) {
                throw new Error('SnREPL: Could not get command ' + cid);
            }

            var state = gr.getValue('u_state');
            var response = gr.getValue('u_response');

            if (state == 'done') {
                break;
            }

            gs.sleep(SnREPL.COMMAND_POLL_INTERVAL);
            t = stopwatch.getTime();
        }

        return response;
    },


    /**
     * Converts the exception generated by ServiceNow into a string
     * that can be parsed on the client.
     *
     * @param {any} ex exception object to serialize
     * @returns {string} JSON string of exception object
     */
    _serializeException: function(ex) {
        const exObj = {};
        Object.getOwnPropertyNames(ex).forEach((key) => {
            exObj[key] = ex[key];
        });
        // rhinoException is a Java object, so we need to force string conversion
        if ('rhinoException' in ex) {
            exObj.rhinoException = String(ex.rhinoException);
        }
        return JSON.stringify(exObj);
    },

    /**
     * Watch for new commands of a given session and process them.
     *
     * This background process will regularly poll the command queue
     * for new commands and process them. The results will be written
     * back to the command record, so they can be picked up by
     * the REST API handler and forwarded to the client.
     */
    watchCommands: function() {
        var __stopwatch = new GlideStopWatch();
        var __t = 0;
	var __delay = SnREPL.WORKER_MIN_DELAY;

	// Intercept calls to gs.print, gs.info, gs.warn, gs.error
	var __printLog = [];
	gs.print = function(msg) {
	    __printLog.push(msg);
	};

        while (__t < SnREPL.WORKER_TTL * 1000) {
            var __gr = new GlideRecord('u_repl_command');
            __gr.addEncodedQuery('u_state=new');
            __gr.query();

            if (__gr.next()) {
 //               var __gse = new GlideScopedEvaluator();

                var __result;
		var __output;
		__printLog = [];

                try {
		      __result = GlideEvaluator.evaluateString(__gr.getValue('u_command'));
//                    __result = __gse.evaluateScript(__gr, 'u_command');
//		    var script = "(function() { return " + __gr.getValue('u_command') + " })();";
//			__gr.getValue('u_command');
//		    __result = eval(script);
                } catch (e) {
                    gs.warn('SnREPL Error: ' + e.message);
                    __result = e.message;
                }

		var response = {
		    result: __result,
		    printLog: __printLog
		}

                __gr.setValue('u_response', JSON.stringify(response));
                __gr.setValue('u_state', 'done');
                __gr.update();
		__delay = SnREPL.WORKER_MIN_DELAY;
            }

            gs.sleep(__delay);
            __t = __stopwatch.getTime();

	    if (__delay < SnREPL.WORKER_MAX_DELAY) {
		__delay += SnREPL.WORKER_LAYOFF_DELAY;
	    }
        }
    },


    /** @type { string } */
    type: 'SnREPL'
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-06-09 19:09:20</sys_created_on>
        <sys_id>c0c16b3793224210bcf170718bba10f0</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>SnREPL</sys_name>
        <sys_package display_value="snREPL" source="a6af973b93ee0210bcf170718bba1066">a6af973b93ee0210bcf170718bba1066</sys_package>
        <sys_policy/>
        <sys_scope display_value="snREPL">a6af973b93ee0210bcf170718bba1066</sys_scope>
        <sys_update_name>sys_script_include_c0c16b3793224210bcf170718bba10f0</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-06-09 19:09:20</sys_updated_on>
    </sys_script_include>
</record_update>
